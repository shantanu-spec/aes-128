#include <iostream>
#include <iomanip>
#include <cstdint>

using namespace std;

const int Nb = 4; // Number of columns comprising the State
const int Nk = 4; // Number of 32-bit words comprising the Cipher Key
const int Nr = 10; // Total Number of rounds for AES -128

// S-box for AES-128 bit standard in a 1D array
const uint8_t sbox[256] = {
0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16};

// Round_key for transformation
const uint8_t roundKeys[Nr+1][Nk*4]= {
{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f},  //round[0] key- Master Key
{0xd6,0xaa,0x74,0xfd,0xd2,0xaf,0x72,0xfa,0xda,0xa6,0x78,0xf1,0xd6,0xab,0x76,0xfe},  //round[1] key
{0xb6,0x92,0xcf,0x0b,0x64,0x3d,0xbd,0xf1,0xbe,0x9b,0xc5,0x00,0x68,0x30,0xb3,0xfe},  //round[2] key
{0xb6,0xff,0x74,0x4e,0xd2,0xc2,0xc9,0xbf,0x6c,0x59,0x0c,0xbf,0x04,0x69,0xbf,0x41},  //round[3] key
{0x47,0xf7,0xf7,0xbc,0x95,0x35,0x3e,0x03,0xf9,0x6c,0x32,0xbc,0xfd,0x05,0x8d,0xfd},  //round[4] key
{0x3c,0xaa,0xa3,0xe8,0xa9,0x9f,0x9d,0xeb,0x50,0xf3,0xaf,0x57,0xad,0xf6,0x22,0xaa},  //round[5] key
{0x5e,0x39,0x0f,0x7d,0xf7,0xa6,0x92,0x96,0xa7,0x55,0x3d,0xc1,0x0a,0xa3,0x1f,0x6b},  //round[6] key
{0x14,0xf9,0x70,0x1a,0xe3,0x5f,0xe2,0x8c,0x44,0x0a,0xdf,0x4d,0x4e,0xa9,0xc0,0x26},  //round[7] key
{0x47,0x43,0x87,0x35,0xa4,0x1c,0x65,0xb9,0xe0,0x16,0xba,0xf4,0xae,0xbf,0x7a,0xd2},  //round[8] key
{0x54,0x99,0x32,0xd1,0xf0,0x85,0x57,0x68,0x10,0x93,0xed,0x9c,0xbe,0x2c,0x97,0x4e},  //round[9] key
{0x13,0x11,0x1d,0x7f,0xe3,0x94,0x4a,0x17,0xf3,0x07,0xa7,0x8b,0x4d,0x2b,0x30,0xc5}}; //round[10] key


//SubByte substitution subroutine for AES
//subtitute values by looking up the s-box matrix of AES
void SubBytes(uint8_t state[4][Nb]){
    for (int i=0; i<4; i++){
        for (int j=0; j<Nb; j++){
            state[i][j] = sbox[state[i][j]];
        }
    }
}


/*ShiftRows subroutine for AES
first row no shift
second row left shift 1
third row left shift 2
fourth row left shift 3*/

void ShiftRows(uint8_t state[4][Nb]){
    uint8_t temp[4][Nb];
    for (int j = 0; j < Nb; j++){
        for (int i = 0; i < 4; i++){
            temp[i][j] = state[(i + j) % 4][j];
        }
    }

    for (int j = 0; j < Nb; j++){
        for (int i = 0; i < 4; i++){
            state[i][j] = temp[i][j];
        }
    }
}

//Galois field mulitplication operator of MixColumn subroutine operation


uint8_t mul2(uint8_t x) {
    return (x & 0x80) ? ((x << 1) ^ 0x1b) : (x << 1);  //if the MSB bit is set, then left shift and xor with 0x1b else only left shift by 1(multiply by 2)
    // divide by GF(2)[x]= x^8+x^4+x^3+x+1 gives xor with x^4+x^3+x+1 which is 00011011 which gives 0x1b
}

// Function to multiply by 3 in Galois Field is just xor with mul2
uint8_t mul3(uint8_t x) {
    return mul2(x) ^ x;
}

// MixColumns transformation for AES 128
void MixColumns(uint8_t state[4][Nb]) {
    uint8_t temp[4][Nb];

    for (int i = 0; i < 4; i++) {
//store matrix multiplication values after Galios function into temp matrix
        temp[i][0] = mul2(state[i][0]) ^ mul3(state[i][1]) ^ state[i][2] ^ state[i][3];
        temp[i][1] = state[i][0] ^ mul2(state[i][1]) ^ mul3(state[i][2]) ^ state[i][3];
        temp[i][2] = state[i][0] ^ state[i][1] ^ mul2(state[i][2]) ^ mul3(state[i][3]);
        temp[i][3] = mul3(state[i][0]) ^ state[i][1] ^ state[i][2] ^ mul2(state[i][3]);
    }

    // copy values from temp matrix to state matrix

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 4; j++) {
            state[i][j] = temp[i][j];
        }
    }
}

//AddRoundKey subroutine where the state matrix is xored directly with corresponding values in RoundKey matrix
void AddRoundKey(uint8_t state[4][Nb], const uint8_t roundKeys[Nr+1][Nk*4], int round) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < Nb; j++) {
            state[i][j] ^= roundKeys[round][i * Nb + j];
        }
    }
}


//function to help print the values for printtext and ciphertext arrays
void printHex(const uint8_t *data, size_t size) {
    for (size_t i = 0; i < size; i++) {
        cout << hex << setw(2) << setfill('0') << (int)data[i];
        if (i < size - 1) cout << "";
    }
    cout << endl;
}

//print all states of the AES encryption transformations
void printState(uint8_t state[4][Nb]){
      for (int i =0;i < 4; i++){
        for(int j =0; j<Nb; j++)
        cout << hex << setw(2) << setfill('0') << (int)state[i][j];
    }
       cout << endl;
}


// Main function to Encrypt AES -128 system with all the subroutines and print values
void Encrypt(uint8_t in[4*Nb], uint8_t out[4*Nb], const uint8_t roundKeys[Nr+1][4*Nb]){
    uint8_t state[4][Nb];

    // Copy input to state array
    for (int i = 0; i < 4*Nb; i++) {
        state[i / Nb][i % Nb] = in[i];
    }

    // Print initial plaintext and Master Key for the system
    cout <<"***********AES-128 ENCRYPTION***************************\n";
    cout << "Plaintext:       ";
    printHex(in, 4*Nb);
    cout << "Master Key:      ";
    printHex(roundKeys[0],4*Nk);
    cout <<"********************************************************\n";
    // Initial transformation (round 0)
    cout << "round[0].input:  ";
    printState(state);
    cout <<"********************************************************\n";

    AddRoundKey(state, roundKeys, 0);
    cout << "round[1].start:  ";  // Adjusted from round[0].start to round[1].start
    printState(state);

    // Main rounds [Round 2-9]
    for (int round = 1; round < Nr; round++) {
        SubBytes(state);
        cout << "round[" << round << "].s_box:  ";
        printState(state);

        ShiftRows(state);
        cout << "round[" << round << "].s_rows: ";
        printState(state);

        MixColumns(state);
        cout << "round[" << round << "].m_col:  ";
        printState(state);

        cout<<"********************************************************\n";

        AddRoundKey(state, roundKeys, round);
        cout << "round[" << round + 1 << "].start:  "; 
        printState(state);
        
    }

    // Final round (no MixColumns) [Round 10]
    SubBytes(state);
    cout << "round[" << Nr << "].s_box:  ";
    printState(state);

    ShiftRows(state);
    cout << "round[" << Nr << "].s_rows: ";
    printState(state);

    AddRoundKey(state, roundKeys, Nr);
    cout << "round[" << Nr << "].output: ";  // This is the final output- Ciphertext
    printState(state);

    // Copy state array to output (ciphertext)
    for (int i = 0; i < 4*Nb; i++) {
        out[i] = state[i / Nb][i % Nb];
    }
    cout<<"********************************************************\n";
    // Print final ciphertext
    cout << "Ciphertext:      ";
    printHex(out, 4*Nb);
}

int main() {
    uint8_t plaintext[4*Nb] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff}; //Given Plaintext
    uint8_t ciphertext[4*Nb];

    Encrypt(plaintext, ciphertext, roundKeys);      // Calling the Encrypt function to start the AES-128 encryption for the given plaintext and key

     return 0;
}